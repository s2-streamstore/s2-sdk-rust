pub mod account;
pub mod basin;
pub mod stream;

use std::{
    pin::Pin,
    task::{Context, Poll},
};

use backon::{ConstantBuilder, Retryable};
use futures::StreamExt;
use prost_types::method_options::IdempotencyLevel;
use secrecy::{ExposeSecret, SecretString};
use tonic::metadata::{AsciiMetadataValue, MetadataMap};

use crate::types::ConvertError;

#[derive(Debug, Clone, thiserror::Error)]
pub enum ServiceError<T: std::error::Error> {
    #[error("Message conversion: {0}")]
    Convert(ConvertError),
    #[error("Internal server error")]
    Internal,
    #[error("{0} currently not supported")]
    NotSupported(String),
    #[error("User not authenticated: {0}")]
    Unauthenticated(String),
    #[error("Unavailable: {0}")]
    Unavailable(String),
    #[error("{0}")]
    Unknown(String),
    #[error(transparent)]
    Remote(T),
}

pub async fn send_request<T: ServiceRequest>(
    service: T,
    token: &SecretString,
    basin: Option<&str>,
) -> Result<T::Response, ServiceError<T::Error>> {
    let retry_fn = || async {
        let mut service = service.clone();

        let mut req = service.prepare_request().map_err(ServiceError::Convert)?;

        add_authorization_header(req.metadata_mut(), token);
        add_basin_header(req.metadata_mut(), basin);

        match service.send(req).await {
            Ok(resp) => service.parse_response(resp).map_err(ServiceError::Convert),
            Err(status) => match status.code() {
                tonic::Code::Internal => Err(ServiceError::Internal),
                tonic::Code::Unimplemented => {
                    Err(ServiceError::NotSupported(status.message().to_string()))
                }
                tonic::Code::Unauthenticated => {
                    Err(ServiceError::Unauthenticated(status.message().to_string()))
                }
                tonic::Code::Unavailable => {
                    Err(ServiceError::Unavailable(status.message().to_string()))
                }
                _ => match service.parse_status(&status) {
                    Ok(resp) => Ok(resp),
                    Err(None) => Err(ServiceError::Unknown(status.message().to_string())),
                    Err(Some(e)) => Err(ServiceError::Remote(e)),
                },
            },
        }
    };

    // TODO: Configure retry.
    Retryable::retry(retry_fn, ConstantBuilder::default())
        .when(|e| match e {
            // Always retry on unavailable (if the request doesn't have any
            // side-effects).
            ServiceError::Unavailable(_)
                if matches!(
                    T::IDEMPOTENCY_LEVEL,
                    IdempotencyLevel::NoSideEffects | IdempotencyLevel::Idempotent
                ) =>
            {
                true
            }
            e => service.should_retry(e),
        })
        .await
}

fn add_authorization_header(meta: &mut MetadataMap, token: &SecretString) {
    let mut val: AsciiMetadataValue = format!("Bearer {}", token.expose_secret())
        .try_into()
        .unwrap();
    val.set_sensitive(true);
    meta.insert("authorization", val);
}

fn add_basin_header(meta: &mut MetadataMap, basin: Option<&str>) {
    if let Some(basin) = basin {
        meta.insert("s2-basin", basin.parse().unwrap());
    }
}

pub trait ServiceRequest: Clone {
    /// Request parameters generated by prost.
    type ApiRequest;
    /// Response to be returned by the RPC.
    type Response;
    /// Response generated by prost to be returned.
    type ApiResponse;
    /// Error to be returned by the RPC.
    ///
    /// Shouldn't be just `tonic::Status`. Need to have meaningful errors.
    type Error: std::error::Error;

    /// The request does not have any side effects (for sure).
    const IDEMPOTENCY_LEVEL: IdempotencyLevel;

    /// Take the request parameters and generate the corresponding tonic request.
    fn prepare_request(&self) -> Result<tonic::Request<Self::ApiRequest>, ConvertError>;

    /// Take the tonic response and generate the response to be returned.
    fn parse_response(
        &self,
        resp: tonic::Response<Self::ApiResponse>,
    ) -> Result<Self::Response, ConvertError>;

    /// Take the tonic status and generate the error.
    fn parse_status(&self, status: &tonic::Status) -> Result<Self::Response, Option<Self::Error>>;

    /// Actually send the tonic request to receive a raw response and the parsed error.
    async fn send(
        &mut self,
        req: tonic::Request<Self::ApiRequest>,
    ) -> Result<tonic::Response<Self::ApiResponse>, tonic::Status>;

    /// Return true if the request should be retried based on the error returned.
    fn should_retry(&self, err: &ServiceError<Self::Error>) -> bool;
}

pub trait WithStreamingRequest: Unpin + ServiceRequest {
    type RequestItem;
    type ApiRequestItem;

    fn prepare_request_item(&self, req: Self::RequestItem) -> Self::ApiRequestItem;
}

pub struct ServiceStreamingRequest<R, S>
where
    R: WithStreamingRequest,
    S: futures::Stream<Item = R::RequestItem> + Unpin,
{
    service_req: R,
    stream: S,
}

impl<R, S> ServiceStreamingRequest<R, S>
where
    R: WithStreamingRequest,
    S: futures::Stream<Item = R::RequestItem> + Unpin,
{
    pub fn new(service_req: R, stream: S) -> Self {
        Self {
            service_req,
            stream,
        }
    }
}

impl<R, S> futures::Stream for ServiceStreamingRequest<R, S>
where
    R: WithStreamingRequest,
    S: futures::Stream<Item = R::RequestItem> + Unpin,
{
    type Item = R::ApiRequestItem;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        match self.stream.poll_next_unpin(cx) {
            Poll::Pending => Poll::Pending,
            Poll::Ready(None) => Poll::Ready(None),
            Poll::Ready(Some(req)) => Poll::Ready(Some(self.service_req.prepare_request_item(req))),
        }
    }
}

pub trait WithStreamingResponse:
    Unpin
    + ServiceRequest<
        Response = ServiceStreamingResponse<Self>,
        ApiResponse = tonic::Streaming<Self::ApiResponseItem>,
    >
{
    /// Response message item to be returned by the RPC stream.
    type ResponseItem;
    /// Response message item generated by prost in the stream.
    type ApiResponseItem;

    /// Take the tonic response message from stream item and generate stream item.
    fn parse_response_item(
        &self,
        resp: Self::ApiResponseItem,
    ) -> Result<Self::ResponseItem, ConvertError>;

    /// Take the tonic status and generate the error.
    fn parse_response_item_status(
        &self,
        status: &tonic::Status,
    ) -> Result<Self::ResponseItem, Option<Self::Error>>;
}

pub struct ServiceStreamingResponse<S: WithStreamingResponse> {
    stream: tonic::Streaming<S::ApiResponseItem>,
    service_req: S,
}

impl<S: WithStreamingResponse> ServiceStreamingResponse<S> {
    pub fn new(service_req: S, stream: tonic::Streaming<S::ApiResponseItem>) -> Self {
        Self {
            stream,
            service_req,
        }
    }
}

impl<S: WithStreamingResponse> futures::Stream for ServiceStreamingResponse<S> {
    type Item = Result<S::ResponseItem, ServiceError<S::Error>>;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        match self.stream.poll_next_unpin(cx) {
            Poll::Pending => Poll::Pending,
            Poll::Ready(None) => Poll::Ready(None),
            Poll::Ready(Some(item)) => {
                let item = match item {
                    Ok(resp) => self
                        .service_req
                        .parse_response_item(resp)
                        .map_err(ServiceError::Convert),
                    Err(status) => match status.code() {
                        tonic::Code::Internal => Err(ServiceError::Internal),
                        tonic::Code::Unimplemented => {
                            Err(ServiceError::NotSupported(status.message().to_string()))
                        }
                        tonic::Code::Unauthenticated => {
                            Err(ServiceError::Unauthenticated(status.message().to_string()))
                        }
                        tonic::Code::Unavailable => {
                            Err(ServiceError::Unavailable(status.message().to_string()))
                        }
                        _ => match self.service_req.parse_response_item_status(&status) {
                            Ok(resp) => Ok(resp),
                            Err(None) => Err(ServiceError::Unknown(status.message().to_string())),
                            Err(Some(e)) => Err(ServiceError::Remote(e)),
                        },
                    },
                };
                Poll::Ready(Some(item))
            }
        }
    }
}

/// Wrapper around `ServiceStreamingResponse` to expose publically.
pub struct StreamingResponse<R, E: std::error::Error>(
    Box<dyn Unpin + futures::Stream<Item = Result<R, ServiceError<E>>>>,
);

impl<R, E: std::error::Error> StreamingResponse<R, E> {
    pub(crate) fn new<S>(s: ServiceStreamingResponse<S>) -> Self
    where
        S: WithStreamingResponse<ResponseItem = R, Error = E> + 'static,
    {
        Self(Box::new(s))
    }
}

impl<R, E: std::error::Error> futures::Stream for StreamingResponse<R, E> {
    type Item = Result<R, ServiceError<E>>;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        self.0.poll_next_unpin(cx)
    }
}
