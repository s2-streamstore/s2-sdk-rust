// This file is @generated by prost-build.
/// List basins request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListBasinsRequest {
    /// List basin names that begin with this prefix.
    #[prost(string, tag = "1")]
    pub prefix: ::prost::alloc::string::String,
    /// Only return basins names that lexicographically start after this name.
    /// This can be the last basin name seen in a previous listing, to continue from there.
    /// It must be greater than or equal to the prefix if specified.
    #[prost(string, tag = "2")]
    pub start_after: ::prost::alloc::string::String,
    /// Number of results, up to a maximum of 1000.
    #[prost(uint64, optional, tag = "3")]
    pub limit: ::core::option::Option<u64>,
}
/// List basins response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBasinsResponse {
    /// Matching basins.
    #[prost(message, repeated, tag = "1")]
    pub basins: ::prost::alloc::vec::Vec<BasinInfo>,
    /// If set, indicates there are more results that can be listed with `start_after`.
    #[prost(bool, tag = "2")]
    pub has_more: bool,
}
/// Create basin request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateBasinRequest {
    /// Basin name, which must be globally unique.
    /// The name must be between 8 and 48 characters, comprising lowercase letters, numbers and hyphens.
    /// It cannot begin or end with a hyphen.
    #[prost(string, tag = "1")]
    pub basin: ::prost::alloc::string::String,
    /// Basin configuration.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<BasinConfig>,
    /// Basin scope.
    #[prost(enumeration = "BasinScope", tag = "3")]
    pub scope: i32,
}
/// Create basin response.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateBasinResponse {
    /// Information about the newly created basin.
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<BasinInfo>,
}
/// Delete basin request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteBasinRequest {
    /// Name of the basin to delete.
    #[prost(string, tag = "1")]
    pub basin: ::prost::alloc::string::String,
}
/// Delete basin response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteBasinResponse {}
/// Get basin configuration request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBasinConfigRequest {
    /// Basin name.
    #[prost(string, tag = "1")]
    pub basin: ::prost::alloc::string::String,
}
/// Get basin configuration response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBasinConfigResponse {
    /// Basin configuration.
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<BasinConfig>,
}
/// Reconfigure basin request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReconfigureBasinRequest {
    /// Basin name.
    #[prost(string, tag = "1")]
    pub basin: ::prost::alloc::string::String,
    /// Basin configuration.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<BasinConfig>,
    /// Specifies the pieces of configuration being updated.
    /// See <https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask>
    #[prost(message, optional, tag = "3")]
    pub mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Reconfigure basin response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReconfigureBasinResponse {
    /// Basin configuration.
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<BasinConfig>,
}
/// Issue access token request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IssueAccessTokenRequest {
    /// Access token information.
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<AccessTokenInfo>,
}
/// Read/Write permissions.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadWritePermissions {
    /// Read permission.
    #[prost(bool, tag = "1")]
    pub read: bool,
    /// Write permission.
    #[prost(bool, tag = "2")]
    pub write: bool,
}
/// Access permissions for a group.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PermittedOperationGroups {
    /// Access permissions at account level.
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<ReadWritePermissions>,
    /// Access permissions at basin level.
    #[prost(message, optional, tag = "2")]
    pub basin: ::core::option::Option<ReadWritePermissions>,
    /// Access permissions at stream level.
    #[prost(message, optional, tag = "3")]
    pub stream: ::core::option::Option<ReadWritePermissions>,
}
/// Revoke access token request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RevokeAccessTokenRequest {
    /// Token to revoke.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Revoke access token response.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RevokeAccessTokenResponse {
    /// Access token information.
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<AccessTokenInfo>,
}
/// List access tokens request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAccessTokensRequest {
    /// List access tokens that begin with this prefix.
    #[prost(string, tag = "1")]
    pub prefix: ::prost::alloc::string::String,
    /// Only return access tokens that lexicographically start after this ID.
    #[prost(string, tag = "2")]
    pub start_after: ::prost::alloc::string::String,
    /// Number of results, up to a maximum of 1000.
    #[prost(uint64, optional, tag = "3")]
    pub limit: ::core::option::Option<u64>,
}
/// List access tokens response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessTokensResponse {
    /// Access tokens information.
    #[prost(message, repeated, tag = "1")]
    pub access_tokens: ::prost::alloc::vec::Vec<AccessTokenInfo>,
    /// If set, indicates there are more results that can be listed with `start_after`.
    #[prost(bool, tag = "2")]
    pub has_more: bool,
}
/// Access token information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AccessTokenInfo {
    /// Access token ID.
    /// It must be unique to the account and between 1 and 96 characters.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Expiration time in seconds since Unix epoch.
    /// If not set, the expiration will be set to that of the requestor's token.
    #[prost(uint32, optional, tag = "2")]
    pub expires_at: ::core::option::Option<u32>,
    /// Namespace streams based on the configured stream-level scope, which must be a prefix.
    /// Stream name arguments will be automatically prefixed, and the prefix will be stripped
    /// when listing streams.
    #[prost(bool, tag = "3")]
    pub auto_prefix_streams: bool,
    /// Access token scope.
    #[prost(message, optional, tag = "4")]
    pub scope: ::core::option::Option<AccessTokenScope>,
}
/// Access token scope.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AccessTokenScope {
    /// Basin names allowed.
    #[prost(message, optional, tag = "1")]
    pub basins: ::core::option::Option<ResourceSet>,
    /// Stream names allowed.
    #[prost(message, optional, tag = "2")]
    pub streams: ::core::option::Option<ResourceSet>,
    /// Token IDs allowed.
    #[prost(message, optional, tag = "3")]
    pub access_tokens: ::core::option::Option<ResourceSet>,
    /// Access permissions at operation group level.
    #[prost(message, optional, tag = "4")]
    pub op_groups: ::core::option::Option<PermittedOperationGroups>,
    /// Operations allowed for the token.
    /// A union of allowed operations and groups is used as an effective set of allowed operations.
    #[prost(enumeration = "Operation", repeated, tag = "5")]
    pub ops: ::prost::alloc::vec::Vec<i32>,
}
/// Set of named resources.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResourceSet {
    /// Matching rule.
    #[prost(oneof = "resource_set::Matching", tags = "1, 2")]
    pub matching: ::core::option::Option<resource_set::Matching>,
}
/// Nested message and enum types in `ResourceSet`.
pub mod resource_set {
    /// Matching rule.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Matching {
        /// Match only the resource with this exact name.
        /// Use an empty string to match no resources.
        #[prost(string, tag = "1")]
        Exact(::prost::alloc::string::String),
        /// Match all resources that start with this prefix.
        /// Use an empty string to match all resource.
        #[prost(string, tag = "2")]
        Prefix(::prost::alloc::string::String),
    }
}
/// Issue access token response.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IssueAccessTokenResponse {
    /// Created access token.
    #[prost(string, tag = "1")]
    pub access_token: ::prost::alloc::string::String,
}
/// Stream information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StreamInfo {
    /// Stream name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Creation time in seconds since Unix epoch.
    #[prost(uint32, tag = "2")]
    pub created_at: u32,
    /// Deletion time in seconds since Unix epoch, if the stream is being deleted.
    #[prost(uint32, optional, tag = "3")]
    pub deleted_at: ::core::option::Option<u32>,
}
/// List streams request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListStreamsRequest {
    /// List stream names that begin with this prefix.
    #[prost(string, tag = "1")]
    pub prefix: ::prost::alloc::string::String,
    /// Only return stream names that lexicographically start after this name.
    /// This can be the last stream name seen in a previous listing, to continue from there.
    /// It must be greater than or equal to the prefix if specified.
    #[prost(string, tag = "2")]
    pub start_after: ::prost::alloc::string::String,
    /// Number of results, up to a maximum of 1000.
    #[prost(uint64, optional, tag = "3")]
    pub limit: ::core::option::Option<u64>,
}
/// List streams response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStreamsResponse {
    /// Matching streams.
    #[prost(message, repeated, tag = "1")]
    pub streams: ::prost::alloc::vec::Vec<StreamInfo>,
    /// If set, indicates there are more results that can be listed with `start_after`.
    #[prost(bool, tag = "2")]
    pub has_more: bool,
}
/// Create stream request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateStreamRequest {
    /// Stream name, which must be unique within the basin.
    /// It can be an arbitrary string upto 512 characters.
    /// Backslash (`/`) is recommended as a delimiter for hierarchical naming.
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    /// Configuration for the new stream.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<StreamConfig>,
}
/// Create stream response.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateStreamResponse {
    /// Information about the newly created stream.
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<StreamInfo>,
}
/// Delete stream request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteStreamRequest {
    /// Stream name.
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
}
/// Delete stream response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteStreamResponse {}
/// Get stream configuration request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetStreamConfigRequest {
    /// Stream name.
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
}
/// Get stream configuration response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetStreamConfigResponse {
    /// Stream configuration.
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<StreamConfig>,
}
/// Reconfigure stream request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReconfigureStreamRequest {
    /// Stream name.
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    /// Stream configuration with updated values.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<StreamConfig>,
    /// Specifies the pieces of configuration being updated.
    /// See <https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask>
    #[prost(message, optional, tag = "3")]
    pub mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Reconfigure stream response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReconfigureStreamResponse {
    /// Stream configuration.
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<StreamConfig>,
}
/// Check tail request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CheckTailRequest {
    /// Stream name.
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
}
/// Check tail response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CheckTailResponse {
    /// Sequence number that will be assigned to the next record on the stream.
    /// It will be 0 for a stream that has not been written to.
    #[prost(uint64, tag = "1")]
    pub next_seq_num: u64,
    /// Timestamp of the last durable record on the stream.
    /// It starts out as 0 for a new stream.
    #[prost(uint64, tag = "2")]
    pub last_timestamp: u64,
}
/// Input for append requests.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendInput {
    /// Stream name. Optional for subsequent requests in the session.
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    /// Batch of records to append atomically, which must contain at least one record, and no more than 1000.
    /// The total size of a batch of records may not exceed 1MiB of metered bytes.
    #[prost(message, repeated, tag = "2")]
    pub records: ::prost::alloc::vec::Vec<AppendRecord>,
    /// Enforce that the sequence number issued to the first record matches.
    #[prost(uint64, optional, tag = "3")]
    pub match_seq_num: ::core::option::Option<u64>,
    /// Enforce a fencing token which must have been previously set by a `fence` command record.
    #[prost(string, optional, tag = "4")]
    pub fencing_token: ::core::option::Option<::prost::alloc::string::String>,
}
/// Output from append response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AppendOutput {
    /// Sequence number of first record appended.
    #[prost(uint64, tag = "1")]
    pub start_seq_num: u64,
    /// Timestamp of the first record appended.
    #[prost(uint64, tag = "4")]
    pub start_timestamp: u64,
    /// Sequence number of last record appended + 1.
    /// `end_seq_num - start_seq_num` will be the number of records in the batch.
    #[prost(uint64, tag = "2")]
    pub end_seq_num: u64,
    /// Timestamp of the last record appended.
    #[prost(uint64, tag = "5")]
    pub end_timestamp: u64,
    /// Tail of the stream, i.e. sequence number that will be assigned to the next record.
    /// This can be greater than `end_seq_num` in case of concurrent appends.
    #[prost(uint64, tag = "3")]
    pub next_seq_num: u64,
    /// Timestamp of the last durable record on the stream.
    #[prost(uint64, tag = "6")]
    pub last_timestamp: u64,
}
/// Append request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendRequest {
    /// Request parameters for an append.
    #[prost(message, optional, tag = "1")]
    pub input: ::core::option::Option<AppendInput>,
}
/// Append response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AppendResponse {
    /// Response details for an append.
    #[prost(message, optional, tag = "1")]
    pub output: ::core::option::Option<AppendOutput>,
}
/// Append session request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendSessionRequest {
    /// Request parameters for an append.
    #[prost(message, optional, tag = "1")]
    pub input: ::core::option::Option<AppendInput>,
}
/// Append session response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AppendSessionResponse {
    /// Response details for an append.
    #[prost(message, optional, tag = "1")]
    pub output: ::core::option::Option<AppendOutput>,
}
/// Output of a read.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadOutput {
    /// Batch of records or the next sequence number on the stream.
    #[prost(oneof = "read_output::Output", tags = "1, 3")]
    pub output: ::core::option::Option<read_output::Output>,
}
/// Nested message and enum types in `ReadOutput`.
pub mod read_output {
    /// Batch of records or the next sequence number on the stream.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Output {
        /// Batch of records.
        /// It can only be empty when not in a session context,
        /// if the request cannot be satisfied without violating its limit.
        #[prost(message, tag = "1")]
        Batch(super::SequencedRecordBatch),
        /// Tail of the stream, i.e. sequence number that will be assigned to the next record.
        /// It will be returned if the requested starting position is greater than the tail,
        /// or only in case of a limited read, equal to it.
        /// It will also be returned if there are no records on the stream between the
        /// requested starting position and the tail.
        #[prost(uint64, tag = "3")]
        NextSeqNum(u64),
    }
}
/// Read request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadRequest {
    /// Stream name.
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    /// Limit how many records can be returned.
    /// This will get capped at the default limit,
    /// which is up to 1000 records or 1MiB of metered bytes.
    #[prost(message, optional, tag = "3")]
    pub limit: ::core::option::Option<ReadLimit>,
    /// Exclusive timestamp to read until.
    /// If provided, this is applied as an additional constraint on top of the `limit`,
    /// and will guarantee that all records returned have timestamps \< the provided `until`.
    #[prost(uint64, optional, tag = "6")]
    pub until: ::core::option::Option<u64>,
    /// Clamp the start position at the tail position.
    /// If set, the read will start at the tail of the stream if the requested position is greater than it.
    #[prost(bool, tag = "7")]
    pub clamp: bool,
    /// Starting position for records.
    /// Retrieved batches will start at the first record whose position is greater than or equal to it.
    #[prost(oneof = "read_request::Start", tags = "2, 4, 5")]
    pub start: ::core::option::Option<read_request::Start>,
}
/// Nested message and enum types in `ReadRequest`.
pub mod read_request {
    /// Starting position for records.
    /// Retrieved batches will start at the first record whose position is greater than or equal to it.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Start {
        /// Sequence number.
        #[prost(uint64, tag = "2")]
        SeqNum(u64),
        /// Timestamp.
        #[prost(uint64, tag = "4")]
        Timestamp(u64),
        /// Number of records before the tail, i.e. before the next sequence number.
        #[prost(uint64, tag = "5")]
        TailOffset(u64),
    }
}
/// Read response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadResponse {
    /// Response details for a read.
    #[prost(message, optional, tag = "1")]
    pub output: ::core::option::Option<ReadOutput>,
}
/// Limit how many records can be retrieved.
/// If both count and bytes are specified, either limit may be hit.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadLimit {
    /// Record count limit.
    #[prost(uint64, optional, tag = "1")]
    pub count: ::core::option::Option<u64>,
    /// Metered bytes limit.
    #[prost(uint64, optional, tag = "2")]
    pub bytes: ::core::option::Option<u64>,
}
/// Read session request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadSessionRequest {
    /// Stream name.
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    /// Limit on how many records can be returned. When a limit is specified, the session will be terminated as soon as
    /// the limit is met, or when the current tail of the stream is reached -- whichever occurs first.
    /// If no limit is specified, the session will remain open after catching up to the tail, and continue tailing as
    /// new messages are written to the stream.
    #[prost(message, optional, tag = "3")]
    pub limit: ::core::option::Option<ReadLimit>,
    /// Heartbeats can be enabled to monitor end-to-end session health.
    /// A heartbeat will be sent when the initial switch to real-time tailing happens,
    /// as well as when no records are available at a randomized interval between 5 and 15 seconds.
    #[prost(bool, tag = "4")]
    pub heartbeats: bool,
    /// Exclusive timestamp to read until.
    /// If provided, this is applied as an additional constraint on top of the `limit`,
    /// and will guarantee that all records returned have timestamps \< the provided `until`.
    #[prost(uint64, optional, tag = "7")]
    pub until: ::core::option::Option<u64>,
    /// Clamp the start position at the tail position.
    #[prost(bool, tag = "8")]
    pub clamp: bool,
    /// Starting position for records.
    /// Retrieved batches will start at the first record whose position is greater than or equal to it.
    #[prost(oneof = "read_session_request::Start", tags = "2, 5, 6")]
    pub start: ::core::option::Option<read_session_request::Start>,
}
/// Nested message and enum types in `ReadSessionRequest`.
pub mod read_session_request {
    /// Starting position for records.
    /// Retrieved batches will start at the first record whose position is greater than or equal to it.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Start {
        /// Sequence number.
        #[prost(uint64, tag = "2")]
        SeqNum(u64),
        /// Timestamp.
        #[prost(uint64, tag = "5")]
        Timestamp(u64),
        /// Number of records before the tail, i.e. the next sequence number.
        #[prost(uint64, tag = "6")]
        TailOffset(u64),
    }
}
/// Read session response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadSessionResponse {
    /// Response details for a read.
    /// This will not be set in case of a heartbeat message.
    #[prost(message, optional, tag = "1")]
    pub output: ::core::option::Option<ReadOutput>,
}
/// Stream configuration.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StreamConfig {
    /// Storage class for recent writes.
    #[prost(enumeration = "StorageClass", tag = "1")]
    pub storage_class: i32,
    /// Timestamping behavior.
    #[prost(message, optional, tag = "5")]
    pub timestamping: ::core::option::Option<stream_config::Timestamping>,
    /// Delete-on-empty configuration.
    #[prost(message, optional, tag = "6")]
    pub delete_on_empty: ::core::option::Option<stream_config::DeleteOnEmpty>,
    /// Retention policy for the stream.
    /// If unspecified, the default is to retain records for 7 days.
    #[prost(oneof = "stream_config::RetentionPolicy", tags = "2, 7")]
    pub retention_policy: ::core::option::Option<stream_config::RetentionPolicy>,
}
/// Nested message and enum types in `StreamConfig`.
pub mod stream_config {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Timestamping {
        /// Timestamping mode for appends that influences how timestamps are handled.
        #[prost(enumeration = "super::TimestampingMode", tag = "1")]
        pub mode: i32,
        /// Allow client-specified timestamps to exceed the arrival time.
        /// If this is false or not set, client timestamps will be capped at the arrival time.
        #[prost(bool, optional, tag = "2")]
        pub uncapped: ::core::option::Option<bool>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DeleteOnEmpty {
        /// Minimum age in seconds before an empty stream can be deleted.
        /// Set to 0 (default) to disable (don't delete automatically).
        #[prost(uint64, tag = "1")]
        pub min_age_secs: u64,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct InfiniteRetention {}
    /// Retention policy for the stream.
    /// If unspecified, the default is to retain records for 7 days.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum RetentionPolicy {
        /// Age in seconds for automatic trimming of records older than this threshold.
        /// This must be set to a value greater than 0 seconds.
        /// (While S2 is in public preview, this is capped at 28 days. Let us know if you'd like the cap removed.)
        #[prost(uint64, tag = "2")]
        Age(u64),
        /// Retain records unless explicitly trimmed.
        #[prost(message, tag = "7")]
        Infinite(InfiniteRetention),
    }
}
/// Basin configuration.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BasinConfig {
    /// Default stream configuration.
    #[prost(message, optional, tag = "1")]
    pub default_stream_config: ::core::option::Option<StreamConfig>,
    /// Create stream on append if it doesn't exist,
    /// using the default stream configuration.
    #[prost(bool, tag = "2")]
    pub create_stream_on_append: bool,
    /// Create stream on read if it doesn't exist,
    /// using the default stream configuration.
    #[prost(bool, tag = "3")]
    pub create_stream_on_read: bool,
}
/// Basin information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BasinInfo {
    /// Basin name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Basin scope.
    #[prost(enumeration = "BasinScope", tag = "5")]
    pub scope: i32,
    /// Basin state.
    #[prost(enumeration = "BasinState", tag = "4")]
    pub state: i32,
}
/// Headers add structured information to a record as name-value pairs.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Header {
    /// Header name blob.
    /// The name cannot be empty, with the exception of an S2 command record.
    #[prost(bytes = "bytes", tag = "1")]
    pub name: ::prost::bytes::Bytes,
    /// Header value blob.
    #[prost(bytes = "bytes", tag = "2")]
    pub value: ::prost::bytes::Bytes,
}
/// Record to be appended to a stream.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendRecord {
    /// Timestamp for this record.
    /// Precise semantics depend on the stream's `timestamping` config.
    #[prost(uint64, optional, tag = "3")]
    pub timestamp: ::core::option::Option<u64>,
    /// Series of name-value pairs for this record.
    #[prost(message, repeated, tag = "1")]
    pub headers: ::prost::alloc::vec::Vec<Header>,
    /// Body of this record.
    #[prost(bytes = "bytes", tag = "2")]
    pub body: ::prost::bytes::Bytes,
}
/// Record retrieved from a stream.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SequencedRecord {
    /// Sequence number assigned to this record.
    #[prost(uint64, tag = "1")]
    pub seq_num: u64,
    /// Timestamp for this record.
    #[prost(uint64, tag = "4")]
    pub timestamp: u64,
    /// Series of name-value pairs for this record.
    #[prost(message, repeated, tag = "2")]
    pub headers: ::prost::alloc::vec::Vec<Header>,
    /// Body of this record.
    #[prost(bytes = "bytes", tag = "3")]
    pub body: ::prost::bytes::Bytes,
}
/// A batch of sequenced records.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SequencedRecordBatch {
    /// Batch of sequenced records.
    #[prost(message, repeated, tag = "1")]
    pub records: ::prost::alloc::vec::Vec<SequencedRecord>,
}
/// Basin scope.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BasinScope {
    /// Unspecified basin scope.
    Unspecified = 0,
    /// aws us-east-1 region.
    AwsUsEast1 = 1,
}
impl BasinScope {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BASIN_SCOPE_UNSPECIFIED",
            Self::AwsUsEast1 => "BASIN_SCOPE_AWS_US_EAST_1",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BASIN_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
            "BASIN_SCOPE_AWS_US_EAST_1" => Some(Self::AwsUsEast1),
            _ => None,
        }
    }
}
/// API operations.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Operation {
    /// Unspecified operation.
    Unspecified = 0,
    /// List basins.
    ListBasins = 1,
    /// Create a basin.
    CreateBasin = 2,
    /// Delete a basin.
    DeleteBasin = 3,
    /// Update basin configuration.
    ReconfigureBasin = 4,
    /// Get basin configuration.
    GetBasinConfig = 5,
    /// Issue an access token.
    IssueAccessToken = 6,
    /// Revoke an access token.
    RevokeAccessToken = 7,
    /// List access tokens.
    ListAccessTokens = 8,
    /// List streams.
    ListStreams = 9,
    /// Create a stream.
    CreateStream = 10,
    /// Delete a stream.
    DeleteStream = 11,
    /// Get stream configuration.
    GetStreamConfig = 12,
    /// Update stream configuration.
    ReconfigureStream = 13,
    /// Check tail of a stream.
    CheckTail = 14,
    /// Append records to a stream.
    Append = 15,
    /// Read records from a stream.
    Read = 16,
    /// Trim records up to a sequence number.
    Trim = 17,
    /// Set a fencing token for a stream.
    Fence = 18,
    /// Retrieve account-level metrics.
    AccountMetrics = 19,
    /// Retrieve basin-level metrics.
    BasinMetrics = 20,
    /// Retrieve stream-level metrics.
    StreamMetrics = 21,
}
impl Operation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OPERATION_UNSPECIFIED",
            Self::ListBasins => "OPERATION_LIST_BASINS",
            Self::CreateBasin => "OPERATION_CREATE_BASIN",
            Self::DeleteBasin => "OPERATION_DELETE_BASIN",
            Self::ReconfigureBasin => "OPERATION_RECONFIGURE_BASIN",
            Self::GetBasinConfig => "OPERATION_GET_BASIN_CONFIG",
            Self::IssueAccessToken => "OPERATION_ISSUE_ACCESS_TOKEN",
            Self::RevokeAccessToken => "OPERATION_REVOKE_ACCESS_TOKEN",
            Self::ListAccessTokens => "OPERATION_LIST_ACCESS_TOKENS",
            Self::ListStreams => "OPERATION_LIST_STREAMS",
            Self::CreateStream => "OPERATION_CREATE_STREAM",
            Self::DeleteStream => "OPERATION_DELETE_STREAM",
            Self::GetStreamConfig => "OPERATION_GET_STREAM_CONFIG",
            Self::ReconfigureStream => "OPERATION_RECONFIGURE_STREAM",
            Self::CheckTail => "OPERATION_CHECK_TAIL",
            Self::Append => "OPERATION_APPEND",
            Self::Read => "OPERATION_READ",
            Self::Trim => "OPERATION_TRIM",
            Self::Fence => "OPERATION_FENCE",
            Self::AccountMetrics => "OPERATION_ACCOUNT_METRICS",
            Self::BasinMetrics => "OPERATION_BASIN_METRICS",
            Self::StreamMetrics => "OPERATION_STREAM_METRICS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATION_UNSPECIFIED" => Some(Self::Unspecified),
            "OPERATION_LIST_BASINS" => Some(Self::ListBasins),
            "OPERATION_CREATE_BASIN" => Some(Self::CreateBasin),
            "OPERATION_DELETE_BASIN" => Some(Self::DeleteBasin),
            "OPERATION_RECONFIGURE_BASIN" => Some(Self::ReconfigureBasin),
            "OPERATION_GET_BASIN_CONFIG" => Some(Self::GetBasinConfig),
            "OPERATION_ISSUE_ACCESS_TOKEN" => Some(Self::IssueAccessToken),
            "OPERATION_REVOKE_ACCESS_TOKEN" => Some(Self::RevokeAccessToken),
            "OPERATION_LIST_ACCESS_TOKENS" => Some(Self::ListAccessTokens),
            "OPERATION_LIST_STREAMS" => Some(Self::ListStreams),
            "OPERATION_CREATE_STREAM" => Some(Self::CreateStream),
            "OPERATION_DELETE_STREAM" => Some(Self::DeleteStream),
            "OPERATION_GET_STREAM_CONFIG" => Some(Self::GetStreamConfig),
            "OPERATION_RECONFIGURE_STREAM" => Some(Self::ReconfigureStream),
            "OPERATION_CHECK_TAIL" => Some(Self::CheckTail),
            "OPERATION_APPEND" => Some(Self::Append),
            "OPERATION_READ" => Some(Self::Read),
            "OPERATION_TRIM" => Some(Self::Trim),
            "OPERATION_FENCE" => Some(Self::Fence),
            "OPERATION_ACCOUNT_METRICS" => Some(Self::AccountMetrics),
            "OPERATION_BASIN_METRICS" => Some(Self::BasinMetrics),
            "OPERATION_STREAM_METRICS" => Some(Self::StreamMetrics),
            _ => None,
        }
    }
}
/// Storage class for recent writes.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StorageClass {
    /// Defaults to `STORAGE_CLASS_EXPRESS`.
    Unspecified = 0,
    /// Standard, which offers end-to-end latencies under 500 ms.
    Standard = 1,
    /// Express, which offers end-to-end latencies under 50 ms.
    Express = 2,
}
impl StorageClass {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STORAGE_CLASS_UNSPECIFIED",
            Self::Standard => "STORAGE_CLASS_STANDARD",
            Self::Express => "STORAGE_CLASS_EXPRESS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STORAGE_CLASS_UNSPECIFIED" => Some(Self::Unspecified),
            "STORAGE_CLASS_STANDARD" => Some(Self::Standard),
            "STORAGE_CLASS_EXPRESS" => Some(Self::Express),
            _ => None,
        }
    }
}
/// Timestamping mode.
/// Note that arrival time is always in milliseconds since Unix epoch.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TimestampingMode {
    /// Defaults to `TIMESTAMPING_MODE_CLIENT_PREFER`.
    Unspecified = 0,
    /// Prefer client-specified timestamp if present otherwise use arrival time.
    ClientPrefer = 1,
    /// Require a client-specified timestamp and reject the append if it is missing.
    ClientRequire = 2,
    /// Use the arrival time and ignore any client-specified timestamp.
    Arrival = 3,
}
impl TimestampingMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TIMESTAMPING_MODE_UNSPECIFIED",
            Self::ClientPrefer => "TIMESTAMPING_MODE_CLIENT_PREFER",
            Self::ClientRequire => "TIMESTAMPING_MODE_CLIENT_REQUIRE",
            Self::Arrival => "TIMESTAMPING_MODE_ARRIVAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TIMESTAMPING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "TIMESTAMPING_MODE_CLIENT_PREFER" => Some(Self::ClientPrefer),
            "TIMESTAMPING_MODE_CLIENT_REQUIRE" => Some(Self::ClientRequire),
            "TIMESTAMPING_MODE_ARRIVAL" => Some(Self::Arrival),
            _ => None,
        }
    }
}
/// Current state of the basin.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BasinState {
    /// Unspecified.
    Unspecified = 0,
    /// Basin is active.
    Active = 1,
    /// Basin is being created.
    Creating = 2,
    /// Basin is being deleted.
    Deleting = 3,
}
impl BasinState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BASIN_STATE_UNSPECIFIED",
            Self::Active => "BASIN_STATE_ACTIVE",
            Self::Creating => "BASIN_STATE_CREATING",
            Self::Deleting => "BASIN_STATE_DELETING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BASIN_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "BASIN_STATE_ACTIVE" => Some(Self::Active),
            "BASIN_STATE_CREATING" => Some(Self::Creating),
            "BASIN_STATE_DELETING" => Some(Self::Deleting),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod account_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Operate on an S2 account.
    #[derive(Debug, Clone)]
    pub struct AccountServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AccountServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AccountServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AccountServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AccountServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// List basins.
        pub async fn list_basins(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBasinsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBasinsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.AccountService/ListBasins",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.AccountService", "ListBasins"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new basin.
        /// Provide a client request token with the `S2-Request-Token` header for idempotent retry behaviour.
        pub async fn create_basin(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBasinRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateBasinResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.AccountService/CreateBasin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.AccountService", "CreateBasin"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a basin.
        /// Basin deletion is asynchronous, and may take a few minutes to complete.
        pub async fn delete_basin(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBasinRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteBasinResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.AccountService/DeleteBasin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.AccountService", "DeleteBasin"));
            self.inner.unary(req, path, codec).await
        }
        /// Update basin configuration.
        pub async fn reconfigure_basin(
            &mut self,
            request: impl tonic::IntoRequest<super::ReconfigureBasinRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReconfigureBasinResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.AccountService/ReconfigureBasin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("s2.v1alpha.AccountService", "ReconfigureBasin"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get basin configuration.
        pub async fn get_basin_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBasinConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBasinConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.AccountService/GetBasinConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.AccountService", "GetBasinConfig"));
            self.inner.unary(req, path, codec).await
        }
        /// Issue a new access token.
        pub async fn issue_access_token(
            &mut self,
            request: impl tonic::IntoRequest<super::IssueAccessTokenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IssueAccessTokenResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.AccountService/IssueAccessToken",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("s2.v1alpha.AccountService", "IssueAccessToken"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Revoke an access token.
        pub async fn revoke_access_token(
            &mut self,
            request: impl tonic::IntoRequest<super::RevokeAccessTokenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RevokeAccessTokenResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.AccountService/RevokeAccessToken",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("s2.v1alpha.AccountService", "RevokeAccessToken"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List access tokens.
        pub async fn list_access_tokens(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAccessTokensRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAccessTokensResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.AccountService/ListAccessTokens",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("s2.v1alpha.AccountService", "ListAccessTokens"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod account_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AccountServiceServer.
    #[async_trait]
    pub trait AccountService: std::marker::Send + std::marker::Sync + 'static {
        /// List basins.
        async fn list_basins(
            &self,
            request: tonic::Request<super::ListBasinsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBasinsResponse>,
            tonic::Status,
        >;
        /// Create a new basin.
        /// Provide a client request token with the `S2-Request-Token` header for idempotent retry behaviour.
        async fn create_basin(
            &self,
            request: tonic::Request<super::CreateBasinRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateBasinResponse>,
            tonic::Status,
        >;
        /// Delete a basin.
        /// Basin deletion is asynchronous, and may take a few minutes to complete.
        async fn delete_basin(
            &self,
            request: tonic::Request<super::DeleteBasinRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteBasinResponse>,
            tonic::Status,
        >;
        /// Update basin configuration.
        async fn reconfigure_basin(
            &self,
            request: tonic::Request<super::ReconfigureBasinRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReconfigureBasinResponse>,
            tonic::Status,
        >;
        /// Get basin configuration.
        async fn get_basin_config(
            &self,
            request: tonic::Request<super::GetBasinConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBasinConfigResponse>,
            tonic::Status,
        >;
        /// Issue a new access token.
        async fn issue_access_token(
            &self,
            request: tonic::Request<super::IssueAccessTokenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IssueAccessTokenResponse>,
            tonic::Status,
        >;
        /// Revoke an access token.
        async fn revoke_access_token(
            &self,
            request: tonic::Request<super::RevokeAccessTokenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RevokeAccessTokenResponse>,
            tonic::Status,
        >;
        /// List access tokens.
        async fn list_access_tokens(
            &self,
            request: tonic::Request<super::ListAccessTokensRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAccessTokensResponse>,
            tonic::Status,
        >;
    }
    /// Operate on an S2 account.
    #[derive(Debug)]
    pub struct AccountServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AccountServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AccountServiceServer<T>
    where
        T: AccountService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/s2.v1alpha.AccountService/ListBasins" => {
                    #[allow(non_camel_case_types)]
                    struct ListBasinsSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::ListBasinsRequest>
                    for ListBasinsSvc<T> {
                        type Response = super::ListBasinsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListBasinsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::list_basins(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListBasinsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.AccountService/CreateBasin" => {
                    #[allow(non_camel_case_types)]
                    struct CreateBasinSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::CreateBasinRequest>
                    for CreateBasinSvc<T> {
                        type Response = super::CreateBasinResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateBasinRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::create_basin(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateBasinSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.AccountService/DeleteBasin" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteBasinSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::DeleteBasinRequest>
                    for DeleteBasinSvc<T> {
                        type Response = super::DeleteBasinResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteBasinRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::delete_basin(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteBasinSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.AccountService/ReconfigureBasin" => {
                    #[allow(non_camel_case_types)]
                    struct ReconfigureBasinSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::ReconfigureBasinRequest>
                    for ReconfigureBasinSvc<T> {
                        type Response = super::ReconfigureBasinResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReconfigureBasinRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::reconfigure_basin(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReconfigureBasinSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.AccountService/GetBasinConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetBasinConfigSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::GetBasinConfigRequest>
                    for GetBasinConfigSvc<T> {
                        type Response = super::GetBasinConfigResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBasinConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::get_basin_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBasinConfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.AccountService/IssueAccessToken" => {
                    #[allow(non_camel_case_types)]
                    struct IssueAccessTokenSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::IssueAccessTokenRequest>
                    for IssueAccessTokenSvc<T> {
                        type Response = super::IssueAccessTokenResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::IssueAccessTokenRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::issue_access_token(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = IssueAccessTokenSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.AccountService/RevokeAccessToken" => {
                    #[allow(non_camel_case_types)]
                    struct RevokeAccessTokenSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::RevokeAccessTokenRequest>
                    for RevokeAccessTokenSvc<T> {
                        type Response = super::RevokeAccessTokenResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RevokeAccessTokenRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::revoke_access_token(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RevokeAccessTokenSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.AccountService/ListAccessTokens" => {
                    #[allow(non_camel_case_types)]
                    struct ListAccessTokensSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::ListAccessTokensRequest>
                    for ListAccessTokensSvc<T> {
                        type Response = super::ListAccessTokensResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListAccessTokensRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::list_access_tokens(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListAccessTokensSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AccountServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "s2.v1alpha.AccountService";
    impl<T> tonic::server::NamedService for AccountServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated client implementations.
pub mod basin_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Operate on an S2 basin.
    #[derive(Debug, Clone)]
    pub struct BasinServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BasinServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BasinServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BasinServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BasinServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// List streams.
        pub async fn list_streams(
            &mut self,
            request: impl tonic::IntoRequest<super::ListStreamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListStreamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.BasinService/ListStreams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.BasinService", "ListStreams"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a stream.
        /// Provide a client request token with the `S2-Request-Token` header for idempotent retry behaviour.
        pub async fn create_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateStreamResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.BasinService/CreateStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.BasinService", "CreateStream"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a stream.
        /// Stream deletion is asynchronous, and may take a few minutes to complete.
        pub async fn delete_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteStreamResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.BasinService/DeleteStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.BasinService", "DeleteStream"));
            self.inner.unary(req, path, codec).await
        }
        /// Get stream configuration.
        pub async fn get_stream_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStreamConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetStreamConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.BasinService/GetStreamConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.BasinService", "GetStreamConfig"));
            self.inner.unary(req, path, codec).await
        }
        /// Update stream configuration.
        pub async fn reconfigure_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::ReconfigureStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReconfigureStreamResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.BasinService/ReconfigureStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.BasinService", "ReconfigureStream"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod basin_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with BasinServiceServer.
    #[async_trait]
    pub trait BasinService: std::marker::Send + std::marker::Sync + 'static {
        /// List streams.
        async fn list_streams(
            &self,
            request: tonic::Request<super::ListStreamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListStreamsResponse>,
            tonic::Status,
        >;
        /// Create a stream.
        /// Provide a client request token with the `S2-Request-Token` header for idempotent retry behaviour.
        async fn create_stream(
            &self,
            request: tonic::Request<super::CreateStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateStreamResponse>,
            tonic::Status,
        >;
        /// Delete a stream.
        /// Stream deletion is asynchronous, and may take a few minutes to complete.
        async fn delete_stream(
            &self,
            request: tonic::Request<super::DeleteStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteStreamResponse>,
            tonic::Status,
        >;
        /// Get stream configuration.
        async fn get_stream_config(
            &self,
            request: tonic::Request<super::GetStreamConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetStreamConfigResponse>,
            tonic::Status,
        >;
        /// Update stream configuration.
        async fn reconfigure_stream(
            &self,
            request: tonic::Request<super::ReconfigureStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReconfigureStreamResponse>,
            tonic::Status,
        >;
    }
    /// Operate on an S2 basin.
    #[derive(Debug)]
    pub struct BasinServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> BasinServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for BasinServiceServer<T>
    where
        T: BasinService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/s2.v1alpha.BasinService/ListStreams" => {
                    #[allow(non_camel_case_types)]
                    struct ListStreamsSvc<T: BasinService>(pub Arc<T>);
                    impl<
                        T: BasinService,
                    > tonic::server::UnaryService<super::ListStreamsRequest>
                    for ListStreamsSvc<T> {
                        type Response = super::ListStreamsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListStreamsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BasinService>::list_streams(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListStreamsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.BasinService/CreateStream" => {
                    #[allow(non_camel_case_types)]
                    struct CreateStreamSvc<T: BasinService>(pub Arc<T>);
                    impl<
                        T: BasinService,
                    > tonic::server::UnaryService<super::CreateStreamRequest>
                    for CreateStreamSvc<T> {
                        type Response = super::CreateStreamResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateStreamRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BasinService>::create_stream(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateStreamSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.BasinService/DeleteStream" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteStreamSvc<T: BasinService>(pub Arc<T>);
                    impl<
                        T: BasinService,
                    > tonic::server::UnaryService<super::DeleteStreamRequest>
                    for DeleteStreamSvc<T> {
                        type Response = super::DeleteStreamResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteStreamRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BasinService>::delete_stream(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteStreamSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.BasinService/GetStreamConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetStreamConfigSvc<T: BasinService>(pub Arc<T>);
                    impl<
                        T: BasinService,
                    > tonic::server::UnaryService<super::GetStreamConfigRequest>
                    for GetStreamConfigSvc<T> {
                        type Response = super::GetStreamConfigResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetStreamConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BasinService>::get_stream_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetStreamConfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.BasinService/ReconfigureStream" => {
                    #[allow(non_camel_case_types)]
                    struct ReconfigureStreamSvc<T: BasinService>(pub Arc<T>);
                    impl<
                        T: BasinService,
                    > tonic::server::UnaryService<super::ReconfigureStreamRequest>
                    for ReconfigureStreamSvc<T> {
                        type Response = super::ReconfigureStreamResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReconfigureStreamRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BasinService>::reconfigure_stream(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReconfigureStreamSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for BasinServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "s2.v1alpha.BasinService";
    impl<T> tonic::server::NamedService for BasinServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated client implementations.
pub mod stream_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Operate on an S2 stream.
    #[derive(Debug, Clone)]
    pub struct StreamServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl StreamServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> StreamServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> StreamServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            StreamServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Check the tail of the stream.
        pub async fn check_tail(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckTailRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CheckTailResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.StreamService/CheckTail",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.StreamService", "CheckTail"));
            self.inner.unary(req, path, codec).await
        }
        /// Append a batch of records to a stream.
        pub async fn append(
            &mut self,
            request: impl tonic::IntoRequest<super::AppendRequest>,
        ) -> std::result::Result<tonic::Response<super::AppendResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.StreamService/Append",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.StreamService", "Append"));
            self.inner.unary(req, path, codec).await
        }
        /// Append batches of records to a stream continuously, while guaranteeing pipelined requests are processed in order.
        /// If any request fails, the session is terminated.
        pub async fn append_session(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::AppendSessionRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::AppendSessionResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.StreamService/AppendSession",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.StreamService", "AppendSession"));
            self.inner.streaming(req, path, codec).await
        }
        /// Retrieve a batch of records from a stream.
        pub async fn read(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.StreamService/Read",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.StreamService", "Read"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve batches of records from a stream continuously.
        pub async fn read_session(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ReadSessionResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/s2.v1alpha.StreamService/ReadSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("s2.v1alpha.StreamService", "ReadSession"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod stream_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with StreamServiceServer.
    #[async_trait]
    pub trait StreamService: std::marker::Send + std::marker::Sync + 'static {
        /// Check the tail of the stream.
        async fn check_tail(
            &self,
            request: tonic::Request<super::CheckTailRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CheckTailResponse>,
            tonic::Status,
        >;
        /// Append a batch of records to a stream.
        async fn append(
            &self,
            request: tonic::Request<super::AppendRequest>,
        ) -> std::result::Result<tonic::Response<super::AppendResponse>, tonic::Status>;
        /// Server streaming response type for the AppendSession method.
        type AppendSessionStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::AppendSessionResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Append batches of records to a stream continuously, while guaranteeing pipelined requests are processed in order.
        /// If any request fails, the session is terminated.
        async fn append_session(
            &self,
            request: tonic::Request<tonic::Streaming<super::AppendSessionRequest>>,
        ) -> std::result::Result<
            tonic::Response<Self::AppendSessionStream>,
            tonic::Status,
        >;
        /// Retrieve a batch of records from a stream.
        async fn read(
            &self,
            request: tonic::Request<super::ReadRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadResponse>, tonic::Status>;
        /// Server streaming response type for the ReadSession method.
        type ReadSessionStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ReadSessionResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Retrieve batches of records from a stream continuously.
        async fn read_session(
            &self,
            request: tonic::Request<super::ReadSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::ReadSessionStream>,
            tonic::Status,
        >;
    }
    /// Operate on an S2 stream.
    #[derive(Debug)]
    pub struct StreamServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> StreamServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for StreamServiceServer<T>
    where
        T: StreamService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/s2.v1alpha.StreamService/CheckTail" => {
                    #[allow(non_camel_case_types)]
                    struct CheckTailSvc<T: StreamService>(pub Arc<T>);
                    impl<
                        T: StreamService,
                    > tonic::server::UnaryService<super::CheckTailRequest>
                    for CheckTailSvc<T> {
                        type Response = super::CheckTailResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CheckTailRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StreamService>::check_tail(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CheckTailSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.StreamService/Append" => {
                    #[allow(non_camel_case_types)]
                    struct AppendSvc<T: StreamService>(pub Arc<T>);
                    impl<
                        T: StreamService,
                    > tonic::server::UnaryService<super::AppendRequest>
                    for AppendSvc<T> {
                        type Response = super::AppendResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AppendRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StreamService>::append(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AppendSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.StreamService/AppendSession" => {
                    #[allow(non_camel_case_types)]
                    struct AppendSessionSvc<T: StreamService>(pub Arc<T>);
                    impl<
                        T: StreamService,
                    > tonic::server::StreamingService<super::AppendSessionRequest>
                    for AppendSessionSvc<T> {
                        type Response = super::AppendSessionResponse;
                        type ResponseStream = T::AppendSessionStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::AppendSessionRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StreamService>::append_session(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AppendSessionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.StreamService/Read" => {
                    #[allow(non_camel_case_types)]
                    struct ReadSvc<T: StreamService>(pub Arc<T>);
                    impl<
                        T: StreamService,
                    > tonic::server::UnaryService<super::ReadRequest> for ReadSvc<T> {
                        type Response = super::ReadResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StreamService>::read(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReadSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/s2.v1alpha.StreamService/ReadSession" => {
                    #[allow(non_camel_case_types)]
                    struct ReadSessionSvc<T: StreamService>(pub Arc<T>);
                    impl<
                        T: StreamService,
                    > tonic::server::ServerStreamingService<super::ReadSessionRequest>
                    for ReadSessionSvc<T> {
                        type Response = super::ReadSessionResponse;
                        type ResponseStream = T::ReadSessionStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadSessionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StreamService>::read_session(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReadSessionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for StreamServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "s2.v1alpha.StreamService";
    impl<T> tonic::server::NamedService for StreamServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
