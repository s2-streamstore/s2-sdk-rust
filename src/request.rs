use backon::{ConstantBuilder, Retryable};
use tonic::{transport::Channel, IntoRequest};

use crate::{
    api::{self, account_service_client::AccountServiceClient},
    types::{self, ConvertError},
};

#[derive(Debug, Clone, thiserror::Error)]
pub enum ServiceError<T: std::error::Error> {
    #[error("Message conversion: {0}")]
    Convert(ConvertError),
    #[error(transparent)]
    Remote(T),
}

pub async fn send_request<T: ServiceRequest>(
    service: T,
    req: T::Request,
    token: &str,
) -> Result<T::Response, ServiceError<T::Error>> {
    let retry_fn = || async {
        let mut service = service.clone();
        let mut req = service
            .prepare_request(req.clone())
            .map_err(ServiceError::Convert)?;
        req.metadata_mut().insert(
            "authorization",
            format!("Bearer {token}").try_into().unwrap(),
        );
        service.send(req).await.map_err(ServiceError::Remote)
    };
    // TODO: Configure retry.
    let retry = Retryable::retry(retry_fn, ConstantBuilder::default()).when(|e| match e {
        ServiceError::Convert(_) => false,
        ServiceError::Remote(e) => service.retry_if(e),
    });
    let resp = retry.await?;
    service.parse_response(resp).map_err(ServiceError::Convert)
}

pub trait ServiceRequest: Clone {
    /// Request parameters for the RPC.
    type Request: Clone;
    /// Request parameters generated by prost.
    type ApiRequest;
    /// Response to be returned by the RPC.
    type Response;
    /// Response generated by prost to be returned.
    type ApiResponse;
    /// Error to be returned by the RPC.
    ///
    /// Shouldn't be just `tonic::Status`. Need to have meaningful errors.
    type Error: std::error::Error;

    /// Take the request parameters and generate the corresponding tonic request.
    fn prepare_request(
        &self,
        req: Self::Request,
    ) -> Result<tonic::Request<Self::ApiRequest>, ConvertError>;

    /// Take the tonic response and generate the response to be returned.
    fn parse_response(
        &self,
        resp: tonic::Response<Self::ApiResponse>,
    ) -> Result<Self::Response, ConvertError>;

    /// Actually send the tonic request to receive a raw response and the parsed error.
    async fn send(
        &mut self,
        req: tonic::Request<Self::ApiRequest>,
    ) -> Result<tonic::Response<Self::ApiResponse>, Self::Error>;

    /// Return true if the request should be retried based on the error returned.
    fn retry_if(&self, err: &Self::Error) -> bool;
}

#[derive(Debug, Clone)]
pub struct CreateBasinServiceRequest {
    client: AccountServiceClient<Channel>,
}

impl CreateBasinServiceRequest {
    pub fn new(channel: Channel) -> Self {
        Self {
            client: AccountServiceClient::new(channel),
        }
    }
}

impl ServiceRequest for CreateBasinServiceRequest {
    type Request = types::CreateBasinRequest;
    type ApiRequest = api::CreateBasinRequest;
    type Response = types::CreateBasinResponse;
    type ApiResponse = api::CreateBasinResponse;
    type Error = CreateBasinError;

    fn prepare_request(
        &self,
        req: Self::Request,
    ) -> Result<tonic::Request<Self::ApiRequest>, ConvertError> {
        let req: api::CreateBasinRequest = req.try_into()?;
        Ok(req.into_request())
    }

    fn parse_response(
        &self,
        resp: tonic::Response<Self::ApiResponse>,
    ) -> Result<Self::Response, ConvertError> {
        resp.into_inner().try_into()
    }

    async fn send(
        &mut self,
        req: tonic::Request<Self::ApiRequest>,
    ) -> Result<tonic::Response<Self::ApiResponse>, Self::Error> {
        self.client
            .create_basin(req)
            .await
            .map_err(|e| match e.code() {
                tonic::Code::InvalidArgument => {
                    CreateBasinError::InvalidBasinName(e.message().to_string())
                }
                tonic::Code::AlreadyExists => CreateBasinError::BasinAlreadyExists,
                tonic::Code::Unimplemented => {
                    CreateBasinError::NotSupported(e.message().to_string())
                }
                tonic::Code::Internal => CreateBasinError::Internal,
                _ => CreateBasinError::Unknown(e.message().to_string()),
            })
    }

    fn retry_if(&self, _status: &Self::Error) -> bool {
        false
    }
}

#[derive(Debug, Clone, thiserror::Error)]
pub enum CreateBasinError {
    #[error("Invalid basin name: {0}")]
    InvalidBasinName(String),
    #[error("Basin with the name already exists")]
    BasinAlreadyExists,
    #[error("{0} currently not supported")]
    NotSupported(String),
    #[error("Internal server error")]
    Internal,
    #[error("{0}")]
    Unknown(String),
}
