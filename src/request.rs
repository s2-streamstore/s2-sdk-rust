use backon::{ConstantBuilder, Retryable};
use tonic::{transport::Channel, IntoRequest};

use crate::{
    api::{self, account_service_client::AccountServiceClient},
    types::{self, ConvertError},
};

#[derive(Debug, Clone, thiserror::Error)]
pub enum ServiceError<T: std::error::Error> {
    #[error("Message conversion: {0}")]
    Convert(ConvertError),
    #[error("Internal server error")]
    Internal,
    #[error("{0} currently not supported")]
    NotSupported(String),
    #[error("User not authenticated: {0}")]
    Unauthenticated(String),
    #[error("{0}")]
    Unknown(String),
    #[error(transparent)]
    Remote(T),
}

pub async fn send_request<T: ServiceRequest>(
    service: T,
    req: T::Request,
    token: &str,
) -> Result<T::Response, ServiceError<T::Error>> {
    let retry_fn = || async {
        let mut service = service.clone();

        let mut req = service
            .prepare_request(req.clone())
            .map_err(ServiceError::Convert)?;

        req.metadata_mut().insert(
            "authorization",
            format!("Bearer {token}").try_into().unwrap(),
        );

        service.send(req).await.map_err(|status| {
            let message = status.message().to_string();
            match status.code() {
                tonic::Code::Internal => ServiceError::Internal,
                tonic::Code::Unimplemented => ServiceError::NotSupported(message),
                tonic::Code::Unauthenticated => ServiceError::Unauthenticated(message),
                _ => service
                    .parse_status(status)
                    .map(ServiceError::Remote)
                    .unwrap_or(ServiceError::Unknown(message)),
            }
        })
    };

    // TODO: Configure retry.
    let resp = Retryable::retry(retry_fn, ConstantBuilder::default())
        .when(|e| service.retry_if(e))
        .await?;

    service.parse_response(resp).map_err(ServiceError::Convert)
}

pub trait ServiceRequest: Clone {
    /// Request parameters for the RPC.
    type Request: Clone;
    /// Request parameters generated by prost.
    type ApiRequest;
    /// Response to be returned by the RPC.
    type Response;
    /// Response generated by prost to be returned.
    type ApiResponse;
    /// Error to be returned by the RPC.
    ///
    /// Shouldn't be just `tonic::Status`. Need to have meaningful errors.
    type Error: std::error::Error;

    /// Take the request parameters and generate the corresponding tonic request.
    fn prepare_request(
        &self,
        req: Self::Request,
    ) -> Result<tonic::Request<Self::ApiRequest>, ConvertError>;

    /// Take the tonic response and generate the response to be returned.
    fn parse_response(
        &self,
        resp: tonic::Response<Self::ApiResponse>,
    ) -> Result<Self::Response, ConvertError>;

    /// Take the tonic status and generate the error.
    fn parse_status(&self, status: tonic::Status) -> Option<Self::Error>;

    /// Actually send the tonic request to receive a raw response and the parsed error.
    async fn send(
        &mut self,
        req: tonic::Request<Self::ApiRequest>,
    ) -> Result<tonic::Response<Self::ApiResponse>, tonic::Status>;

    /// Return true if the request should be retried based on the error returned.
    fn retry_if(&self, err: &ServiceError<Self::Error>) -> bool;
}

#[derive(Debug, Clone)]
pub struct CreateBasinServiceRequest {
    client: AccountServiceClient<Channel>,
}

impl CreateBasinServiceRequest {
    pub fn new(channel: Channel) -> Self {
        Self {
            client: AccountServiceClient::new(channel),
        }
    }
}

impl ServiceRequest for CreateBasinServiceRequest {
    type Request = types::CreateBasinRequest;
    type ApiRequest = api::CreateBasinRequest;
    type Response = types::CreateBasinResponse;
    type ApiResponse = api::CreateBasinResponse;
    type Error = CreateBasinError;

    fn prepare_request(
        &self,
        req: Self::Request,
    ) -> Result<tonic::Request<Self::ApiRequest>, ConvertError> {
        let req: api::CreateBasinRequest = req.try_into()?;
        Ok(req.into_request())
    }

    fn parse_response(
        &self,
        resp: tonic::Response<Self::ApiResponse>,
    ) -> Result<Self::Response, ConvertError> {
        resp.into_inner().try_into()
    }

    fn parse_status(&self, status: tonic::Status) -> Option<Self::Error> {
        match status.code() {
            tonic::Code::InvalidArgument => Some(CreateBasinError::InvalidBasinName(
                status.message().to_string(),
            )),
            tonic::Code::AlreadyExists => Some(CreateBasinError::BasinAlreadyExists),
            _ => None,
        }
    }

    async fn send(
        &mut self,
        req: tonic::Request<Self::ApiRequest>,
    ) -> Result<tonic::Response<Self::ApiResponse>, tonic::Status> {
        self.client.create_basin(req).await
    }

    fn retry_if(&self, _status: &ServiceError<Self::Error>) -> bool {
        false
    }
}

#[derive(Debug, Clone, thiserror::Error)]
pub enum CreateBasinError {
    #[error("Invalid basin name: {0}")]
    InvalidBasinName(String),
    #[error("Basin with the name already exists")]
    BasinAlreadyExists,
}
